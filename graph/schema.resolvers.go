package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"quizard/graph/model"
	"strings"
	"time"

	jwt "github.com/golang-jwt/jwt/v5"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	//get gin context
	gc, _ := GinContextFromContext(ctx)

	//get token from header
	tokenHeader := gc.GetHeader("Authorization")

	//parse out bearer from token
	accessToken := tokenHeader[len("Bearer "):]

	//parse token and validate claims
	receivedToken, stop := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) {
		claim := token.Claims.(jwt.MapClaims)

		if claim["name"] != "randomstringfornow" { //real auth should check user email or something
			return jwt.ErrTokenInvalidClaims, fmt.Errorf("Cannot parse JWT")
		}
		return base64.URLEncoding.DecodeString("somesecretfornow") //need 256-bit secret
	})
	//verify no errors in token parse
	if stop != nil {
		return &model.User{}, stop
	}
	//verify token is valid
	if !receivedToken.Valid {
		return &model.User{}, fmt.Errorf("jwt not valid")
	}

	newUser, _ := r.CH.BFExists(gc, "users", model.User(input)).Result()

	if !newUser {
		return &model.User{Email: "User exists", Password: ""}, nil
	}

	var answer []*model.User

	//Search by hashed password and email is most desirable
	//the field.keyword matches in a case-sensitive manner
	query := `{ "query": { "match": {"email.keyword": "` + input.Email + `"} } }`

	//stringfy query
	var builder strings.Builder
	builder.WriteString(query)

	results, err := r.DB.Search(r.DB.Search.WithIndex("users"),
		r.DB.Search.WithContext(context.Background()),
		r.DB.Search.WithTrackTotalHits(true),
		r.DB.Search.WithBody(strings.NewReader(builder.String())))

	if err != nil {
		return &model.User{}, err
	}
	// Instantiate a map interface object for storing returned documents
	var mapResp map[string]interface{}

	problem := json.NewDecoder(results.Body).Decode(&mapResp)
	if problem != nil {
		return &model.User{}, problem
	}

	defer results.Body.Close()

	data := mapResp["hits"].(map[string]any)

	var userList []interface{}

	for i := 0; i < len(data); i++ {

		if i == 2 {

			for _, person := range data["hits"].([]interface{}) {

				userList = append(userList, person.(map[string]interface{})["_source"])

			}

		}

	}

	for _, d := range userList {

		res := d.(map[string]interface{})

		userEmail := res["email"]
		userPassword := res["password"]

		f := model.User{
			Email:    userEmail.(string),
			Password: userPassword.(string),
		}

		if f.Email == input.Email || f.Password == input.Password {

			f.Email = "User exists" //if user exists return fake user with message
			f.Password = ""
			return &f, nil
		}

		answer = append(answer, &f)
		r.CH.BFAdd(gc, "users", f) //create bloom filter for users
	}

	//if nothing in db convert UserInput to User for return

	createdUser := model.User(input)

	//add to elasticsearch db
	marshalUser, _ := json.Marshal(createdUser)
	r.DB.Index("users", bytes.NewReader(marshalUser))

	r.CH.BFAdd(gc, "users", createdUser)

	// session := map[string]string{"email": input.Email, "password": input.Password}

	// for k, v := range session {
	// 	err := r.CH.HSet(gc, "user-session", k, v).Err()
	// 	if err != nil {
	// 		fmt.Println(err)
	// 		break
	// 	}
	// }

	return &createdUser, nil
}

// CreateQuiz is the resolver for the createQuiz field. //Upsert operation
func (r *mutationResolver) CreateQuiz(ctx context.Context, input model.SavedQuizInput) (*model.SavedQuiz, error) {
	//get gin context
	gc, _ := GinContextFromContext(ctx)

	//get token from header
	tokenHeader := gc.GetHeader("Authorization")

	//parse out bearer from token
	accessToken := tokenHeader[len("Bearer "):]

	//parse token and validate claims
	receivedToken, stop := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) {
		claim := token.Claims.(jwt.MapClaims)

		if claim["name"] != "randomstringfornow" { //real auth should check user email or something
			return jwt.ErrTokenInvalidClaims, fmt.Errorf("Cannot parse JWT")
		}
		return base64.URLEncoding.DecodeString("somesecretfornow") //need 256-bit secret
	})
	//verify no errors in token parse
	if stop != nil {
		return &model.SavedQuiz{}, stop
	}
	//verify token is valid
	if !receivedToken.Valid {
		return &model.SavedQuiz{}, fmt.Errorf("jwt not valid")
	}

	//if no date, that means this quiz is new
	//so add to db's (elasticsearch and redis)
	if input.ID == "" {

		input.ID = time.Now().String() //timestamp now for date

		var responses []*model.Questions
		for _, v := range input.Responses {

			g := model.Questions{
				Notes:   v.Notes,
				Correct: v.Correct,
			}

			responses = append(responses, &g)
		}
		//create quiz to save to db
		quiz := model.SavedQuiz{
			UserID:    input.UserID, //user's email
			ID:        input.ID,
			Name:      input.Name,
			Responses: responses,
		}

		//add to elasticsearch
		marshaledQuiz, err := json.Marshal(quiz)
		if err != nil {
			return &model.SavedQuiz{}, err
		}
		r.DB.Index("quizzes", bytes.NewReader(marshaledQuiz))

		r.CH.Del(ctx, input.UserID) //delete  from cache after each change
		return &quiz, nil

	}

	//else if date present, check db's for quiz to update

	//find index of quiz to delete in redis list
	//previously I queried the whole list and check by date, but that was slow

	r.CH.Del(ctx, input.UserID) //delete after ea change
	//----------------- Elastic Search ----------------------------------------

	//check elasticsearch
	//Search by hashed password and email is most desirable
	//the field.keyword matches in a case-sensitive manner
	query := `{ "query": { "match": {"id.keyword": "` + input.ID + `"} } }`

	//stringfy query
	var builder strings.Builder
	builder.WriteString(query)

	results, err := r.DB.Search(r.DB.Search.WithIndex("quizzes"),
		r.DB.Search.WithContext(context.Background()),
		r.DB.Search.WithTrackTotalHits(true),
		r.DB.Search.WithBody(strings.NewReader(builder.String())))

	if err != nil {
		return &model.SavedQuiz{}, err
	}

	var mapResp map[string]interface{}

	problem := json.NewDecoder(results.Body).Decode(&mapResp)

	if problem != nil {
		return &model.SavedQuiz{}, problem
	}

	data := mapResp["hits"].(map[string]any)

	var quizList []interface{}

	for i := 0; i < len(data); i++ {

		if i == 2 {

			for _, person := range data["hits"].([]interface{}) {

				quizList = append(quizList, person.(map[string]interface{})["_source"])

			}

		}

	}

	for _, qz := range quizList {

		res := qz.(map[string]interface{})

		if res["id"].(string) == input.ID {
			//delete other quiz
			r.DB.DeleteByQuery([]string{"quizzes"}, strings.NewReader(builder.String()))

			var responses []*model.Questions
			for _, v := range input.Responses {

				g := model.Questions{
					Notes:   v.Notes,
					Correct: v.Correct,
				}

				responses = append(responses, &g)
			}
			quizSaveElasticSearch := model.SavedQuiz{
				UserID:    input.UserID,
				Name:      input.Name,
				ID:        input.ID,
				Responses: responses,
			}

			//collect this quiz
			h, _ := json.Marshal(quizSaveElasticSearch) //should be one quiz
			r.DB.Index("quizzes", bytes.NewReader(h))

			return &quizSaveElasticSearch, nil

		}

	}

	defer results.Body.Close()

	//save this new quiz

	//if quiz has a date , but not in cache or elasticsearch
	//which is more likely now that I timestamp from UI
	//create a SavedQuiz model from input, save it, and return

	var resp []*model.Questions
	for _, v := range input.Responses {

		re := model.Questions{
			Correct: v.Correct,
			Notes:   v.Notes,
		}
		resp = append(resp, &re)
	}

	an := model.SavedQuiz{
		UserID:    input.UserID,
		ID:        input.ID,
		Name:      input.Name,
		Responses: resp,
	}

	s, _ := json.Marshal(an)
	r.DB.Index("quizzes", bytes.NewReader(s))
	return &an, nil
}

// DeleteQuiz is the resolver for the deleteQuiz field.
func (r *mutationResolver) DeleteQuiz(ctx context.Context, input *model.SavedQuizInput) (*model.SavedQuiz, error) {

	gc, err := GinContextFromContext(ctx)
	if err != nil {
		return &model.SavedQuiz{}, err
	}

	//get token from header
	tokenHeader := gc.GetHeader("Authorization")

	//parse out bearer from token
	accessToken := tokenHeader[len("Bearer "):]

	//parse token and validate claims
	receivedToken, stop := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) {
		claim := token.Claims.(jwt.MapClaims)

		if claim["name"] != "randomstringfornow" { //real auth should check user email or something
			return jwt.ErrTokenInvalidClaims, fmt.Errorf("Cannot parse JWT")
		}
		return base64.URLEncoding.DecodeString("somesecretfornow") //need 256-bit secret
	})
	//verify no errors in token parse
	if stop != nil {
		return &model.SavedQuiz{}, stop
	}
	//verify token is valid
	if !receivedToken.Valid {
		return &model.SavedQuiz{}, fmt.Errorf("jwt not valid")
	}

	//remove quiz from cache list
	r.CH.Del(ctx, input.UserID) //delete after ea change

	//----------------- Elastic Search ----------------------------------------

	//check elasticsearch
	//Search by hashed password and email is most desirable
	//the field.keyword matches in a case-sensitive manner
	query := `{ "query": { "match": {"id.keyword": "` + input.ID + `"} } }`

	//stringfy query
	var builder strings.Builder
	builder.WriteString(query)

	r.DB.DeleteByQuery([]string{"quizzes"}, strings.NewReader(builder.String()))

	var responses []*model.Questions

	for _, v := range input.Responses {
		res := model.Questions{

			Notes:   v.Notes,
			Correct: v.Correct,
		}
		responses = append(responses, &res)
	}

	return &model.SavedQuiz{Responses: responses, Name: input.Name, ID: input.ID, UserID: input.UserID}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, email string) ([]*model.User, error) {
	//get gin context for headers
	gc, err := GinContextFromContext(ctx)
	if err != nil {
		return []*model.User{}, err
	}

	//get token from header
	tokenHeader := gc.GetHeader("Authorization")

	//parse out bearer from token
	accessToken := tokenHeader[len("Bearer "):]

	//parse token and validate claims
	receivedToken, stop := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) {
		claim := token.Claims.(jwt.MapClaims)

		if claim["name"] != "randomstringfornow" { //real auth should check user email or something
			return jwt.ErrTokenInvalidClaims, fmt.Errorf("Cannot parse JWT")
		}
		return base64.URLEncoding.DecodeString("somesecretfornow") //need 256-bit secret
	})
	//verify no errors in token parse
	if stop != nil {
		return []*model.User{}, stop
	}
	//verify token is valid
	if !receivedToken.Valid {
		return []*model.User{}, fmt.Errorf("jwt not valid")
	}

	//temp user slice for return
	var answer []*model.User

	//Search by hashed password and email is most desirable
	//the field.keyword matches in a case-sensitive manner
	query := `{ "query": { "match": {"email.keyword": "` + email + `"} } }`

	//stringfy query
	var builder strings.Builder
	builder.WriteString(query)

	results, err := r.DB.Search(r.DB.Search.WithIndex("users"),
		r.DB.Search.WithContext(context.Background()),
		r.DB.Search.WithTrackTotalHits(true),
		r.DB.Search.WithBody(strings.NewReader(builder.String())))

	if err != nil {
		return answer, err
	}
	// Instantiate a map interface object for storing returned documents
	var mapResp map[string]interface{}

	problem := json.NewDecoder(results.Body).Decode(&mapResp)
	if problem != nil {
		return answer, problem
	}

	defer results.Body.Close()

	data := mapResp["hits"].(map[string]any)

	var userList []interface{}

	for i := 0; i < len(data); i++ {

		if i == 2 {

			for _, person := range data["hits"].([]interface{}) {

				userList = append(userList, person.(map[string]interface{})["_source"])

			}

		}

	}

	for _, d := range userList {

		res := d.(map[string]interface{})

		userEmail := res["email"]
		userPassword := res["password"]

		f := model.User{
			Email:    userEmail.(string),
			Password: userPassword.(string),
		}

		answer = append(answer, &f)
		r.CH.BFAdd(gc, "users", f) //create bloom filter for new users
	}

	return answer, nil
}

// Quizzes is the resolver for the quizzes field.
func (r *queryResolver) Quizzes(ctx context.Context, email string) ([]*model.SavedQuiz, error) {
	var result []*model.SavedQuiz

	//get gin context for headers
	gc, err := GinContextFromContext(ctx)
	if err != nil {
		return []*model.SavedQuiz{}, err
	}

	//get token from header
	tokenHeader := gc.GetHeader("Authorization")

	if len(tokenHeader) == 0 {
		return []*model.SavedQuiz{}, fmt.Errorf("No header")
	}

	//parse out bearer from token
	accessToken := tokenHeader[len("Bearer "):]

	//parse token and validate claims
	receivedToken, stop := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) {
		claim := token.Claims.(jwt.MapClaims)

		if claim["name"] != "randomstringfornow" { //real auth should check user email or something
			return jwt.ErrTokenInvalidClaims, fmt.Errorf("Cannot parse JWT")
		}
		return base64.URLEncoding.DecodeString("somesecretfornow") //need 256-bit secret
	})
	//verify no errors in token parse
	if stop != nil {
		return []*model.SavedQuiz{}, stop
	}
	//verify token is valid
	if !receivedToken.Valid {
		return []*model.SavedQuiz{}, fmt.Errorf("jwt not valid")
	}

	//check redis first use Lrange for list and start at 0 end at end of list (so whole list)
	quizzes, prob := r.CH.LRange(gc, email, 0, -1).Result()
	if prob != nil {
		return result, prob
	}

	if len(quizzes) != 0 {

		for _, qz := range quizzes {
			var d model.SavedQuiz
			er := json.Unmarshal([]byte(qz), &d)
			if er != nil {
				return result, err
			}

			result = append(result, &d)
		}
		return result, nil

	}

	//else if nothing in cache (redis) check DB (elasticsearch)

	//----------------- Elastic Search ----------------------------------------

	//check elasticsearch
	//Search by hashed password and email is most desirable
	//the field.keyword matches in a case-sensitive manner
	query := `{ "query": { "match": {"userId.keyword": "` + email + `"} } }`

	//stringfy query
	var builder strings.Builder
	builder.WriteString(query)

	results, err := r.DB.Search(r.DB.Search.WithIndex("quizzes"),
		r.DB.Search.WithContext(context.Background()),
		r.DB.Search.WithTrackTotalHits(true),
		r.DB.Search.WithBody(strings.NewReader(builder.String())))

	if err != nil {
		return []*model.SavedQuiz{}, err
	}

	var mapResp map[string]interface{}

	problem := json.NewDecoder(results.Body).Decode(&mapResp)

	if problem != nil {
		return []*model.SavedQuiz{}, problem
	}

	data := mapResp["hits"].(map[string]any)

	var quizList []interface{}

	for i := 0; i < len(data); i++ {

		if i == 2 {

			for _, person := range data["hits"].([]interface{}) {

				quizList = append(quizList, person.(map[string]interface{})["_source"])

			}

		}

	}

	var quizES []*model.SavedQuiz

	for _, qz := range quizList {

		res := qz.(map[string]interface{})
		var responseList []*model.Questions

		for _, co := range res["responses"].([]interface{}) {

			cd := co.(map[string]interface{})
			correctBool := cd["correct"].(bool)

			modelQuestion := model.Questions{
				Notes:   cd["notes"].(string),
				Correct: &correctBool,
			}
			responseList = append(responseList, &modelQuestion)
		}

		quizSaveElasticSearch := model.SavedQuiz{
			UserID:    res["userId"].(string),
			Name:      res["name"].(string),
			ID:        res["id"].(string),
			Responses: responseList,
		}

		//collect this quiz
		quizES = append(quizES, &quizSaveElasticSearch)

		//add to cache with user email as key
		marshalQuiz, _ := json.Marshal(quizSaveElasticSearch)
		r.CH.RPush(ctx, email, string(marshalQuiz))

	}

	defer results.Body.Close()

	if len(quizES) > 0 {
		return quizES, nil
	}

	return []*model.SavedQuiz{}, nil
}

// GetAuth is the resolver for the getAuth field.
func (r *queryResolver) GetAuth(ctx context.Context) (string, error) {
	//set expiration time
	expiration := time.Now().Add(1 * time.Hour)

	//declare token with HS256 algorithm for signing and claims
	token := jwt.New(jwt.SigningMethodHS256)
	claims := token.Claims.(jwt.MapClaims)
	claims["exp"] = expiration.Unix()     //expires in one hour
	claims["name"] = "randomstringfornow" //real jwt would have user's name or email or something
	claims["auth"] = true

	//token in HMAC requires a slice byte for signed strings
	//https://golang-jwt.github.io/jwt/usage/signing_methods/#signing-methods-and-key-types
	//so we will convert a mock string into a slice byte
	tokenSig, prob := base64.URLEncoding.DecodeString("somesecretfornow")
	if prob != nil {
		return "", prob
	}
	tokenString, err := token.SignedString(tokenSig)
	if err != nil {
		return "", err
	}

	//return token
	return tokenString, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
